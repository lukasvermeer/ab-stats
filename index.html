<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="nl">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>Type-M</title>

		<script type="text/javascript" src="jquery/jquery-3.2.1.js"></script>
		<script type="text/javascript" src="d3/d3.js"></script>
		<script type="text/javascript" src="vue/vue.js"></script>
		<script src="bootstrap/js/bootstrap.min.js"></script>
		
		<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
		<style>
			.alert-nope {
				color: #767676;
				background-color: #f0f0f0;
				border-color: #e9e9e9;
			}
			.form-group-closer {
				margin-bottom: 0px;
			}
			.form-group-closer .alert {
				margin-bottom: 5px;
			}
		</style>
	</head>
	<body>	
		<div id="app-typem" class="container">
			<div class="modal" tabindex="-1" role="dialog" id="paramModal">
				<div class="modal-dialog modal-lg" role="document">
					<div class="modal-content">
						<div class="modal-header">
							<h4 class="modal-title">To start the simulation, please choose one of the following scenarios</h4>
						</div>
						<div class="modal-body">
							<p>This simulation, and the accompanying visualisation and explanations, are intended to illustrate the effects of statistical power on errors in estimations of effect size and direction. Please choose one of the following scenarios.</p>
							<form>
								<div class="form-group form-group-closer" v-for="(v,i) in parameter_sets">
									<div :class="[ (i==selected_parameter_set) ? 'alert alert-success' : 'alert alert-nope']" v-on:click="selected_parameter_set = i">
										<label><input type="radio" name="params" id="params" :value="i" v-model="selected_parameter_set">&nbsp;&nbsp;{{v.title}}</label> <var>n</var> = <var>{{v.n}}</var>, <var>base conversion rate</var> = <var>{{v.cr}}</var>, <var>effect of treatment</var> = <var>{{v.effect}}</var>, <var>power</var> = <var>{{v.power.toLocaleString('nl', {style: 'percent'})}}</var>
										<p>{{v.description}}</p>
										<p v-if="v.recommendation"><b>{{v.recommendation}}</b></p>
									</div>
								</div>
							</form>
							</p><small>For more details about the underlying concepts, and recommendations for experiment design calculations, please refer to <a href="http://www.stat.columbia.edu/~gelman/research/published/PPS551642_REV2.pdf" target="_blank">Beyond Power Calculations: Assessing Type S (Sign) and Type M (Magnitude) Errors</a> by Andrew Gelman and John Carlin.</small></p>
						</div>
						<div class="modal-footer">
							<button type="button" class="btn btn-success" v-on:click="restart" data-dismiss="modal">Start the simulation</button>
						</div>
					</div>
				</div>
			</div>
			
			<div class="modal" tabindex="-1" role="dialog" id="errorsModal">
				<div class="modal-dialog modal-lg" role="document">
					<div class="modal-content">
						<div class="modal-header">
							<h4 class="modal-title"></h4>
						</div>
						<div class="modal-body">
							<p>
								Three concepts are central to this simulation. These will be explained using examples as the simulation unfolds.
								<dl class="dl-horizontal">
									<dt>Power</dt>
									<dd>
										The likelihood that a statistical test will detect a significant effect, assuming the effect actually exists.<br />
										<em>e.g. How likely is it that we will obtain a significant result?</em>
									</dd>
									<dt>Type-M (Magnitude)</dt>
									<dd>
										The expectation of the absolute value of the estimate divided by the simulated effect size, if statistically significantly different from zero.<br />
										<em>e.g. How wrong are we on average about the size of the effect?</em>
									</dd>
									<dt>Type-S (Sign)</dt>
									<dd>
										The probability that the estimate of the effect size has the incorrect sign, if it is statistically significantly different from zero.<br />
										<em>e.g. How often are we wrong about the direction of a significant effect?</em>
									</dd>
								</dl>
							</p>
							</p><small>For more details about the underlying concepts, and recommendations for experiment design calculations, please refer to <a href="http://www.stat.columbia.edu/~gelman/research/published/PPS551642_REV2.pdf" target="_blank">Beyond Power Calculations: Assessing Type S (Sign) and Type M (Magnitude) Errors</a> by Andrew Gelman and John Carlin.</small></p>
						</div>
						<div class="modal-footer">
							<button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
						</div>
					</div>
				</div>
			</div>
		
			<h1 class="text-center">{{parameters.title}} simulation scenario</h1>
			<svg width="1140" height="500"></svg>
			<p></p>
			<div class="row">
				<div class="col-md-6">
					<div class="jumbotron">
						<p class="text-center">number of trials simulated</p>
						<h1 class="text-center">{{trials.toLocaleString('nl')}}</h1>
					</div>
				</div>
				<div class="col-md-6">
					<div class="jumbotron">
						<p class="text-center">observed power</p>
						<h1 class="text-center">{{power.toLocaleString('nl', {style: 'percent'})}}</h1>
					</div>
				</div>
			</div>
			<div class="row">
				<div class="col-md-6">
					<div class="jumbotron">
						<p class="text-center">average observed effect per trial</p>
						<h1 class="text-center">{{averages.total.toFixed(5)}}</h1>
					</div>
				</div>
				<div class="col-md-6">
					<div class="jumbotron">
						<p class="text-center">average observed effect per significant trial</p>
						<h1 class="text-center">{{average_abs_effect.toFixed(5)}}</h1>
					</div>
				</div>
			</div>
			<div class="row">
				<div class="col-md-6">
					<div class="jumbotron">
						<p class="text-center">type-M error</p>
						<h1 class="text-center">{{type_m_error.toLocaleString('nl')}}</h1>
					</div>
				</div>
				<div class="col-md-6">
					<div class="jumbotron">
						<p class="text-center">type-S error</p>
						<h1 class="text-center">{{type_s_error.toLocaleString('nl', {style: 'percent'})}}</h1>
					</div>
				</div>
			</div>
		</div>
		
		<script type="text/javascript">
			var SPEED = 100;

			var svg = d3.select("svg"),
				margin = {top: 10, right: 20, bottom: 20, left: 20},
				width = +svg.attr("width") - margin.left - margin.right,
				height = +svg.attr("height") - margin.top - margin.bottom;

			typem = new Vue({
				el: '#app-typem',
				data: {
					bins: 200,
					parameter_sets: [
						{ n: 1000, cr: 0.1, effect: 0.1, bounds: [0,0.2], power: 1,
							title: 'Massively overpowered',
							description: 'The simulated effect is so large compared to the sample size, it will be almost impossible to miss. This means power is effectively 100%. As a result, the type-M error will be very tiny, and the likelihood of making a type-S error will be negligible.',
							recommendation: 'Try this one first to get an idea of what a good result should look like.'
						},
						{ n: 1000, cr: 0.1, effect: 0.052, bounds: [-0.04,0.144], power: 0.8,
							title: 'Properly powered',
							description: 'We have powered the test according to common practise, so that approximately 80% of all replications will detect a significant effect. As a result, the type-M error will be manageable, and the likelihood of making a type-S error will still be negligible.'
						},
						{ n: 1000, cr: 0.1, effect: 0.025, bounds: [-0.07,0.12], power: 0.35,
							title: 'Somewhat underpowered',
							description: 'We have somewhat underpowered the test, so that approximately 35% of all replications will detect a significant effect. As a result, the type-M error will be substantial, and the likelihood of making a type-S error will start to be noticeable.'
						},
						{ n: 1000, cr: 0.1, effect: 0.001, bounds: [-0.099,0.101], power: 0.1,
							title: 'Massively underpowered',
							description: 'The simulated effect is so tiny compared to the sample size, it will be almost impossible to detect. Power will be effectively only 10%. As a result, the type-M error will be ginormous, and the likelihood of making a type-S error will be substantial.'
						},
						],
					selected_parameter_set: 0,
					results: { significant: [], insignificant: [], significant_opposite: [] },
					g: ''
				},
				computed: {
					parameters: function() {
						return this.parameter_sets[this.selected_parameter_set];
					},
					averages: function() {
						var a = {}, total_sum = 0;
						for (var k in this.results) {
							if (this.results[k].length == 0) { 
								a[k] = NaN;
							} else {
								var sum = this.results[k].reduce(function(a, b) { return a + b; });
								a[k] = sum / this.results[k].length;
								total_sum += sum;
							}
						}
						a.total = total_sum / this.trials;
						return a;
					},
					average_abs_effect: function() {
						return ((this.averages.significant * this.results.significant.length) + 
								(Math.abs(this.averages.significant_opposite||0) * this.results.significant_opposite.length))
								/ (this.results.significant.length + this.results.significant_opposite.length);
					},
					type_m_error: function() {
						return this.average_abs_effect / this.parameters.effect;
					},
					type_s_error: function() {
						return this.results.significant_opposite.length / (this.results.significant.length + this.results.significant_opposite.length);
					},
					trials: function() {
						return this.results.significant.length + this.results.significant_opposite.length + this.results.insignificant.length;
					},
					power: function() {
						return (this.results.significant.length + this.results.significant_opposite.length) / this.trials;
					}
				},
				mounted: function() {
					this.g = d3.select("svg").append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
					this.update(this.results);
				},
				methods: {
					update: function(data) {
						var x = d3.scaleLinear().domain(this.parameters.bounds).rangeRound([0, width]);
						var histogram = d3.histogram().domain(x.domain()).thresholds(x.ticks(this.bins));
						var b1 = histogram(this.results.significant);
						var b2 = histogram(this.results.insignificant);
						var b3 = histogram(this.results.significant_opposite);
						var b = d3.stack().keys(d3.range(3))(d3.transpose([b1.map(function(d) {return d.length}),b2.map(function(d) {return d.length}),b3.map(function(d) {return d.length})]));
						var y = d3.scaleLinear().domain([0, d3.max(b[1], function(d) { return d[1]; })]).range([height, 0]);
						var color = d3.scaleOrdinal().domain(d3.range(3)).range(d3.schemeCategory20);

						var series = this.g.selectAll(".series").data(b);						
						series.enter().append("g")
								.attr("class", "series")
								.attr("fill", function(d, i) { return color(i); })
							.merge(series);

						var rect = series.selectAll("rect").data(function(d) { return d; });
						rect.enter().append("rect")
								.attr("x", 1)
								.attr("width", x(b1[0].x1) - x(b1[0].x0))
								.attr("transform", function(d, i) { return "translate(" + x(b1[i].x0) + "," + y(d[0]) + ")"; })
								.attr("height", 0)
							.merge(rect)
								.transition().duration(SPEED)
									.attr("transform", function(d, i) { return "translate(" + x(b1[i].x0) + "," + y(d[1]) + ")"; })
									.attr("height", function(d) { return height - y(d[1]-d[0]); });
						
						this.g.selectAll(".axis").remove();
						this.g.append("g")
							.attr("class", "axis axis--x")
							.attr("transform", "translate(0," + height + ")")
							.call(d3.axisBottom(x));
					},
					add_one: function() {
						var n = this.trials;
						if (n >= 1000000) return;
						for (var j = 0; j < Math.min(1000,10**(""+(n)).length/10); ++j) {
							base_n = this.rbinom(this.parameters.n, 0.5);
							var_n = this.parameters.n - base_n;
							
							base_c = this.rbinom(base_n, this.parameters.cr);
							var_c = this.rbinom(var_n, (this.parameters.cr + this.parameters.effect));
							
							effect = (var_c/var_n) - (base_c/base_n);
							gval = calculate_g_test([[base_n - base_c, base_c], [var_n - var_c, var_c]]);

							if (gval >= 2.7055) {
								if (effect > 0) {
									this.results.significant.push(effect);
								} else {
									this.results.significant_opposite.push(effect);
								}
							} else {
								this.results.insignificant.push(effect);
							}
						}
					},
					rbinom: function(n, p) {
						var b = 0;
						for (var i = 0; i < n; ++i) { if (Math.random() < p) ++b; };
						return b;
					},
					restart: function() {
						d3.interval(function() { typem.add_one(); }, SPEED);
					}
				},
				watch: {
					trials: function(val) { this.update(val) }
				}
			});
			
			$(function() {
				$("#paramModal").modal({ backdrop: 'static', keyboard: false });
			});
			
			// This takes an array of arrays of any size, and calculates
			// the raw g-test value.  It assumes a square matrix of arguments.
			function calculate_g_test (data) {
				var rows = data.length;
				var columns = data[0].length;

				// Initialize our subtotals
				var row_totals = [];
				for (var i = 0; i < rows; i++) {
					row_totals[i] = 0;
				}

				var column_totals = [];
				for (var j = 0; j < columns; j++) {
					column_totals[j] = 0;
				}

				var total = 0;

				// First we calculate the totals for the row and the column
				for (var i = 0; i < rows; i++) {
					for (var j = 0; j < columns; j++) {
						var entry = data[i][j] - 0;  // - 0 ensures numeric
						row_totals[i]    += entry;
						column_totals[j] += entry;
						total            += entry;
					}
				}

				// Now we calculate the g-test contribution from each entry.
				var g_test = 0;;
				for (var i = 0; i < rows; i++) {
					for (var j = 0; j < columns; j++) {
						var expected = row_totals[i] * column_totals[j] / total;
						var seen     = data[i][j];

						g_test      += 2 * seen * Math.log( seen / expected );
					}
				}

				return g_test;
			};
		</script>
	</body>
</html>